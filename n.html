<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Study Document</title>
    <style>
        :root {
            --a4-width: 595pt; /* 210mm */
            --a4-height: 842pt; /* 297mm */
            --page-margin-top: 56pt; /* approx 2cm */
            --page-margin-bottom: 56pt;
            --page-margin-horizontal: 40pt; /* approx 1.4cm */

            --content-width: calc(var(--a4-width) - 2 * var(--page-margin-horizontal));
            --content-height: calc(var(--a4-height) - var(--page-margin-top) - var(--page-margin-bottom));

            --text-font-size: 10pt;
            --line-height: 1.4;
            --header-font-size: 16pt;
            --question-font-size: 11pt;
        }

        body {
            font-family: 'Times New Roman', Times, serif; /* Classic book font */
            margin: 0;
            background-color: #e0e0e0; /* Neutral background */
            color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            overflow-x: hidden; /* Prevent horizontal scroll on body */
            -webkit-user-select: none; /* Disable text selection during swipes */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            font-size: 12pt;
            color: #333;
            text-decoration: none;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 100;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .back-link:hover {
            background-color: #fff;
        }

        #pageViewer {
            width: var(--a4-width);
            height: var(--a4-height);
            position: relative; /* For absolute positioning of pages */
            overflow: hidden; /* Crucial for swipe transitions */
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            background-color: white; /* Fallback for empty space */
            transition: transform 0.3s ease-in-out; /* For zoom */
        }

        .a4-page {
            width: 100%;
            height: 100%;
            background-color: #fff;
            box-sizing: border-box;
            padding: var(--page-margin-top) var(--page-margin-horizontal) var(--page-margin-bottom) var(--page-margin-horizontal);
            position: absolute;
            top: 0;
            left: 0;
            transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out;
            opacity: 0;
            transform: translateX(100%); /* Start off-screen to the right */
            overflow-y: hidden; /* Prevent scrollbars on individual pages */
            font-size: var(--text-font-size);
            line-height: var(--line-height);
        }

        .a4-page.active {
            opacity: 1;
            transform: translateX(0);
            z-index: 1;
        }

        .a4-page.previous { /* For sliding out to the left */
            transform: translateX(-100%);
            opacity: 0;
            z-index: 0;
        }

        .page-content {
            width: var(--content-width);
            height: var(--content-height);
            overflow: hidden; /* Content should not overflow its designated area */
        }

        .page-number {
            position: absolute;
            bottom: calc(var(--page-margin-bottom) / 2 - 6pt); /* Centered in bottom margin */
            left: 50%;
            transform: translateX(-50%);
            font-size: 9pt;
            color: #555;
        }

        /* Index Page Styles */
        .index-title {
            font-size: 20pt;
            text-align: center;
            margin-bottom: 30pt;
            font-weight: bold;
        }
        .index-list {
            list-style: none;
            padding: 0;
        }
        .index-item {
            display: flex;
            justify-content: space-between;
            font-size: 12pt;
            margin-bottom: 10pt;
            padding-bottom: 5pt;
            border-bottom: 1px dotted #ccc;
        }
        .index-item .subject-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 10pt;
        }
        .index-item .page-ref::before {
            content: "";
            flex-grow: 1;
            border-bottom: 1px dotted #aaa;
            margin: 0 0.5em 0.25em; /* vertical alignment of dots */
        }
        .index-item .page-ref {
             display: flex;
             align-items: baseline; /* aligns subject name with dots */
        }

        /* Content Page Styles */
        .subject-header {
            font-size: var(--header-font-size);
            font-weight: bold;
            margin-top: 0; /* For first subject on page */
            margin-bottom: 15pt;
            padding-bottom: 5pt;
            border-bottom: 1px solid #000;
        }
        .question-item {
            margin-bottom: 12pt;
        }
        .question-item p {
            margin: 0 0 4pt 0;
        }
        .question-number-subject {
            font-weight: bold;
            margin-right: 5pt;
        }
        .question-text-content {
            font-size: var(--question-font-size);
        }
        .answer-text-content {
            color: #38761d; /* Dark green for answer */
            font-weight: bold;
            margin-left: 15pt; /* Indent answer */
        }
        .distractions-list {
            list-style-type: lower-alpha;
            margin-left: 30pt; /* Indent distractions */
            padding-left: 10pt;
            font-size: calc(var(--text-font-size) * 0.95);
            color: #444;
        }
        .distractions-list li {
            margin-bottom: 2pt;
        }

        /* Navigation Buttons */
        .nav-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        .nav-buttons button {
            padding: 10px 20px;
            font-size: 12pt;
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .nav-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .nav-buttons button:hover:not(:disabled) {
            background-color: #eee;
        }

        /* Hidden div for measuring content height */
        #measureDiv {
            position: absolute;
            visibility: hidden;
            width: var(--content-width); /* Must match page content width */
            font-size: var(--text-font-size);
            line-height: var(--line-height);
            padding: 0; margin: 0; /* No extra padding/margin */
            box-sizing: border-box;
            font-family: 'Times New Roman', Times, serif;
        }

        /* Zoom styling */
        #pageViewer.zoomed-in {
            transform: scale(1.5); /* Adjust zoom level as needed */
            /* Could also add margin adjustments if needed when zoomed */
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Main</a>

    <div id="pageViewer">
        <!-- Pages will be injected here by JavaScript -->
    </div>

    <div class="nav-buttons">
        <button id="prevButton" disabled>Previous</button>
        <button id="nextButton" disabled>Next</button>
    </div>

    <!-- Hidden div for measuring content height before adding to a page -->
    <div id="measureDiv"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const jsonDataStorageKey = 'structuredSpreadsheetJsData_v2';
            const pageViewer = document.getElementById('pageViewer');
            const measureDiv = document.getElementById('measureDiv');
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');

            const A4_CONTENT_HEIGHT = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--content-height')) || 730; // in pt

            // --- !!! IMPORTANT: UPDATE THESE KEY NAMES !!! ---
            const KEY_MAPPING = {
                id: "id",
                questionText: "questionText",
                answer: "Answer",       // CHANGE THIS
                subject: "Subject",     // CHANGE THIS
                distractions: [         // CHANGE THESE
                    "Distraction 1",
                    "Distraction 2",
                    "Distraction 3",
                ]
            };
            // --- END IMPORTANT KEY MAPPING ---

            const PREDEFINED_SUBJECT_ORDER = ["physics", "chemistry", "zoology", "botany", "mat"];

            let allPagesData = []; // Array to hold HTML content for each page
            let currentPageIndex = 0;
            let isZoomed = false;

            function createPageElement(isIndexPage = false) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'a4-page';
                if (isIndexPage) pageDiv.classList.add('index-page');

                const contentDiv = document.createElement('div');
                contentDiv.className = 'page-content';
                pageDiv.appendChild(contentDiv);

                return { pageDiv, contentDiv };
            }

            function addPageNumber(pageDiv, number) {
                if (pageDiv.classList.contains('index-page')) return; // No page number for index
                const pageNumSpan = document.createElement('span');
                pageNumSpan.className = 'page-number';
                pageNumSpan.textContent = number;
                pageDiv.appendChild(pageNumSpan);
            }

            function formatQuestionForPage(item, subjectSn) {
                let html = `<div class="question-item">`;
                html += `<p><span class="question-number-subject">${subjectSn}.</span> <span class="question-text-content">${item[KEY_MAPPING.questionText] || 'N/A'}</span></p>`;
                html += `<p class="answer-text-content"><strong>Answer:</strong> ${item[KEY_MAPPING.answer] || 'N/A'}</p>`;

                const distractions = KEY_MAPPING.distractions
                    .map(key => item[key])
                    .filter(d => d && d.trim() !== '');

                if (distractions.length > 0) {
                    html += `<ul class="distractions-list">`;
                    distractions.forEach(d => {
                        html += `<li>${d}</li>`;
                    });
                    html += `</ul>`;
                }
                html += `</div>`;
                return html;
            }

            function measureContentHeight(htmlContent) {
                measureDiv.innerHTML = htmlContent;
                // Apply specific styles if necessary for accurate measurement (e.g., question item specific margins)
                if (htmlContent.includes('class="subject-header"')) {
                    measureDiv.firstElementChild.style.fontSize = getComputedStyle(document.documentElement).getPropertyValue('--header-font-size');
                     measureDiv.firstElementChild.style.marginBottom = '15pt'; // From .subject-header
                } else if (htmlContent.includes('class="question-item"')) {
                     measureDiv.firstElementChild.style.marginBottom = '12pt'; // From .question-item
                }
                return measureDiv.offsetHeight * (72 / 96); // Convert px to pt (approx, depends on browser DPI rendering to screen pixels)
                                                             // More robust: work entirely in pt, or use getBoundingClientRect().height
                                                             // For simplicity, this estimate is used. True pt measurement is harder.
                                                             // Let's try directly measuring:
                // return measureDiv.getBoundingClientRect().height; // This gives height in screen pixels
                // A better way is to set measureDiv font size in pt and assume 1px = 0.75pt (for 96DPI) or use CSS pt directly.
                // Since page elements are styled in pt, let's assume measureDiv respects this.
                // The height offsetHeight gives integer pixels.
                // For now, let's use a rough scaling factor if needed, or assume 1px from offsetHeight is roughly 0.75pt.
                // The most reliable is to keep everything in one unit or use getComputedStyle.
                // The `A4_CONTENT_HEIGHT` is in `pt`. `offsetHeight` is in `px`.
                // A pragmatic way: measureDiv.style.fontSize = getComputedStyle(document.documentElement).getPropertyValue('--text-font-size');
                // Then assume offsetHeight is somewhat proportional.
                // A better approach for true pt height:
                // Let's assume the styles are correctly applied and offsetHeight can be compared IF A4_CONTENT_HEIGHT was in px.
                // Since A4_CONTENT_HEIGHT is in pt, we need conversion or consistent units.
                // For now, let's simplify: measure based on an estimated lines or simpler pixel conversion.
                // Average char width and line height can give a rough estimate.
                // Or: use a fixed lines-per-page estimate.
                // The most robust is the iterative addition and checking offsetHeight against A4 pixel equivalent.
                // Let A4_CONTENT_HEIGHT_PX = A4_CONTENT_HEIGHT * (96/72) for this comparison.
                const A4_CONTENT_HEIGHT_PX = A4_CONTENT_HEIGHT * (4/3); // Approx if 1pt = 1.333px
                return measureDiv.offsetHeight; // Returns height in pixels. Compare this to A4_CONTENT_HEIGHT_PX.
            }


            function paginateData(data) {
                const pages = [];
                const indexEntries = [];

                let { pageDiv: currentPageDiv, contentDiv: currentContentDiv } = createPageElement();
                let currentContentHeight = 0; // in px, from offsetHeight

                const A4_CONTENT_HEIGHT_PX = A4_CONTENT_HEIGHT * (screen.deviceXDPI || 96) / 72; // More dynamic conversion attempt
                                                                                             // Or simpler: A4_CONTENT_HEIGHT * 1.33 if assuming 96DPI

                // Group by subject and sort
                const questionsBySubject = data.reduce((acc, item) => {
                    const rawSubject = item[KEY_MAPPING.subject] || 'Uncategorized';
                    const normalizedSubject = rawSubject.toLowerCase().trim();
                    if (!acc[normalizedSubject]) {
                        acc[normalizedSubject] = [];
                    }
                    acc[normalizedSubject].push(item);
                    return acc;
                }, {});

                const sortedSubjectNames = Object.keys(questionsBySubject).sort((a, b) => {
                    let indexA = PREDEFINED_SUBJECT_ORDER.indexOf(a);
                    let indexB = PREDEFINED_SUBJECT_ORDER.indexOf(b);
                    if (indexA === -1) indexA = PREDEFINED_SUBJECT_ORDER.length; // Put non-predefined at end
                    if (indexB === -1) indexB = PREDEFINED_SUBJECT_ORDER.length;

                    if (indexA !== indexB) return indexA - indexB;
                    return a.localeCompare(b); // Alphabetical for same-priority or non-predefined
                });


                // Create Index Page First
                const { pageDiv: indexPageDiv, contentDiv: indexContentDiv } = createPageElement(true);
                indexPageDiv.classList.add('index-page');
                let indexHtml = `<h1 class="index-title">Index</h1><ul class="index-list">`;
                // Placeholder for index entries, will be filled later
                indexContentDiv.innerHTML = indexHtml + `</ul>`; // Temporary
                pages.push(indexPageDiv);


                // Paginate Content
                let actualPageNumber = 1; // Content pages start from 1

                for (const subjectName of sortedSubjectNames) {
                    let subjectQuestionCount = 0;
                    const subjectDisplayName = subjectName.charAt(0).toUpperCase() + subjectName.slice(1);

                    // Subject Header
                    const subjectHeaderHtml = `<h2 class="subject-header" style="font-size: ${getComputedStyle(document.documentElement).getPropertyValue('--header-font-size')}; margin-bottom: 15pt;">${subjectDisplayName}</h2>`;
                    const subjectHeaderHeight = measureContentHeight(subjectHeaderHtml);

                    if (currentContentHeight + subjectHeaderHeight > A4_CONTENT_HEIGHT_PX && currentContentHeight > 0) {
                        pages.push(currentPageDiv);
                        addPageNumber(currentPageDiv, actualPageNumber++);
                        ({ pageDiv: currentPageDiv, contentDiv: currentContentDiv } = createPageElement());
                        currentContentHeight = 0;
                    }
                    currentContentDiv.innerHTML += subjectHeaderHtml;
                    currentContentHeight += subjectHeaderHeight;
                    indexEntries.push({ name: subjectDisplayName, page: actualPageNumber });


                    for (const item of questionsBySubject[subjectName]) {
                        subjectQuestionCount++;
                        const questionHtml = formatQuestionForPage(item, subjectQuestionCount);
                        const questionHeight = measureContentHeight(questionHtml);

                        if (currentContentHeight + questionHeight > A4_CONTENT_HEIGHT_PX && currentContentHeight > 0) {
                            pages.push(currentPageDiv);
                            addPageNumber(currentPageDiv, actualPageNumber++);
                            ({ pageDiv: currentPageDiv, contentDiv: currentContentDiv } = createPageElement());
                            currentContentHeight = 0;

                            // If new page started, and this is the first item for subject on this page, re-add subject header
                            // This logic can be complex to get perfect (e.g. if subject header alone takes a page)
                            // For simplicity, let's assume subject header fits or we handle it by re-adding.
                            // This might need refinement for edge cases (very long subject headers or tiny pages).
                            // currentContentDiv.innerHTML += subjectHeaderHtml; // Re-add header on new page for same subject
                            // currentContentHeight += subjectHeaderHeight;
                        }
                        currentContentDiv.innerHTML += questionHtml;
                        currentContentHeight += questionHeight;
                    }
                }

                // Add the last page if it has content
                if (currentContentDiv.innerHTML.trim() !== '') {
                    pages.push(currentPageDiv);
                    addPageNumber(currentPageDiv, actualPageNumber++);
                }

                // Finalize Index Page Content
                indexEntries.forEach(entry => {
                     indexHtml += `<li class="index-item"><span class="subject-name">${entry.name}</span><span class="page-ref">${entry.page}</span></li>`;
                });
                indexHtml += `</ul>`;
                pages[0].querySelector('.page-content').innerHTML = indexHtml; // Update the index page

                return pages;
            }


      
